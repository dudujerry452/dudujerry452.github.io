<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库总结 | dudujerry的Coding世界!</title><meta name="author" content="dudujerry"><meta name="copyright" content="dudujerry"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库总结ch1 引言数据抽象  物理层 逻辑层（物理数据独立性） 视图层  数据库定义长期存储在计算机内、有组织的、可共享的大量数据集合 数据库特征   数据按照一定的数据模型组织、描述和存储 可为各种用户共享 冗余度小 数据独立性高 易扩展  数据库管理系统（DBMS） 由一个相互关联的数据的集合和一组用以访问这些数据的程序组成。位于用户与操作系统之间 数据定义语言 (DDL)  定义数据库模">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库总结">
<meta property="og:url" content="https://dudujerry452.github.io/2025/08/21/db-summary/index.html">
<meta property="og:site_name" content="dudujerry的Coding世界!">
<meta property="og:description" content="数据库总结ch1 引言数据抽象  物理层 逻辑层（物理数据独立性） 视图层  数据库定义长期存储在计算机内、有组织的、可共享的大量数据集合 数据库特征   数据按照一定的数据模型组织、描述和存储 可为各种用户共享 冗余度小 数据独立性高 易扩展  数据库管理系统（DBMS） 由一个相互关联的数据的集合和一组用以访问这些数据的程序组成。位于用户与操作系统之间 数据定义语言 (DDL)  定义数据库模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dudujerry452.github.io/img/girl_avater.jpg">
<meta property="article:published_time" content="2025-08-21T01:39:18.000Z">
<meta property="article:modified_time" content="2025-08-21T01:40:22.932Z">
<meta property="article:author" content="dudujerry">
<meta property="article:tag" content="database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dudujerry452.github.io/img/girl_avater.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据库总结",
  "url": "https://dudujerry452.github.io/2025/08/21/db-summary/",
  "image": "https://dudujerry452.github.io/img/girl_avater.jpg",
  "datePublished": "2025-08-21T01:39:18.000Z",
  "dateModified": "2025-08-21T01:40:22.932Z",
  "author": [
    {
      "@type": "Person",
      "name": "dudujerry",
      "url": "https://dudujerry452.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dudujerry452.github.io/2025/08/21/db-summary/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库总结',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/girl_avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/lizard.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">dudujerry的Coding世界!</span></a><a class="nav-page-title" href="/"><span class="site-name">数据库总结</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据库总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-21T01:39:18.000Z" title="发表于 2025-08-21 09:39:18">2025-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-21T01:40:22.932Z" title="更新于 2025-08-21 09:40:22">2025-08-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="数据库总结"><a href="#数据库总结" class="headerlink" title="数据库总结"></a>数据库总结</h1><h1 id="ch1-引言"><a href="#ch1-引言" class="headerlink" title="ch1 引言"></a>ch1 引言</h1><p><strong>数据抽象</strong></p>
<ul>
<li>物理层</li>
<li>逻辑层（物理数据独立性）</li>
<li>视图层</li>
</ul>
<p><strong>数据库定义</strong>长期存储在计算机内、有组织的、可共享的大量数据集合</p>
<p><strong>数据库特征</strong> </p>
<ul>
<li>数据按照一定的数据模型组织、描述和存储</li>
<li>可为各种用户共享</li>
<li>冗余度小</li>
<li>数据独立性高</li>
<li>易扩展</li>
</ul>
<p><strong>数据库管理系统（DBMS）</strong> 由一个相互关联的数据的集合和一组用以访问这些数据的程序组成。位于用户与操作系统之间</p>
<p><strong>数据定义语言 (DDL) </strong> 定义数据库模式和数据的其他特性的语言</p>
<ul>
<li>过程化DML：What and how</li>
<li>声明式DML：What，NO how</li>
<li>查询</li>
</ul>
<p><strong>数据操纵语言（DML） </strong> 使得用户可以操纵和访问那些按照适当模型组织起来的数据</p>
<p><strong>完整性约束</strong></p>
<ul>
<li><strong>域约束</strong>：属性的取值必须在某个域内</li>
<li><strong>参照完整性</strong>：一个关系的属性集上的取值在另一个关系中必须存在</li>
<li><strong>断言</strong> 前二者的超集。数据库需要时刻满足的条件</li>
<li><strong>授权</strong> 给予用户不同的权限</li>
</ul>
<p><strong>实例</strong> 特定时刻存储在数据库中的信息的集合</p>
<p><strong>模式</strong> 数据库的总体设计称作数据库模式</p>
<p><strong>数据库的三级模式结构</strong> </p>
<ul>
<li><strong>外模式</strong>：用户的数据视图；模式的子集；可以有多个</li>
<li><strong>模式</strong>：所有用户的公共数据视图；全体模式；只有一个</li>
<li><p><strong>内模式</strong>：数据的物理结构和存储方式；只有一个</p>
</li>
<li><p>外模式/模式映像；模式/内模式映像</p>
</li>
</ul>
<p><strong>数据独立性</strong> </p>
<ul>
<li><strong>物理数据独立性</strong>：存储结构改变时，修改模式/内模式映像，使模式保持不变，从而使应用程序保持不变；</li>
<li><strong>逻辑数据独立性</strong>：当模式改变时，修改外模式/模式映像，使外模式保持不变，使应用程序可以保持不变</li>
</ul>
<p><strong>数据模型</strong> 描述数据、数据联系、数据语义以及一致性约束的概念工具的集合</p>
<ul>
<li><p><strong>关系模型</strong> 用表的集合表示数据与数据之间的关系</p>
</li>
<li><p><strong>实体-联系模型</strong>  现实世界由实体和实体之间的联系构成，用于数据库设计</p>
</li>
<li><strong>层次模型</strong> 用树结构表示实体之间联系的模型</li>
<li><strong>网状模型</strong> 使用有向图表示实体之间的联系</li>
<li>层次/网状模型的特点：只能处理一对多的实体联系；每个记录类型定义一个排序字段（码字段）；任何记录值只有按照其路径查看才有全部意义</li>
</ul>
<p><strong>特种数据库（数据模型）</strong></p>
<ul>
<li><strong>半结构化数据模型</strong> 允许相同类型的数据项含有不同属性集的数据说明—xml</li>
<li><strong>基于对象的数据模型</strong> 对实体-联系模型进行封装，增加方法、对对象标识的扩展（面向对象/对象-关系数据模型）</li>
</ul>
<p><strong>关系模型的优点</strong> </p>
<ul>
<li>简单，表的概念直观单一，用户易理解</li>
<li>非过程化的数据请求，可以避免“怎么做”</li>
<li>数据独立性</li>
<li>坚实的理论基础</li>
</ul>
<p><strong>规范化</strong> 规范化的目标是生成一个关系模式的集合，没有不必要的冗余。又能轻易检索数据。</p>
<ul>
<li>设计符合适当范式的模式</li>
<li>函数依赖</li>
</ul>
<p><strong>存储管理器</strong> DBMS负责在数据库中存储的底层数据与应用程序以及向系统提交的查询直接提供接口的部件</p>
<ul>
<li>权限及完整性管理器</li>
<li>事务管理器</li>
<li>文件管理器</li>
<li>缓冲区管理器</li>
<li>数据文件</li>
<li>数据字典</li>
<li>索引</li>
</ul>
<p><strong>查询管理器</strong> </p>
<ul>
<li>DDL解释器</li>
<li>DML编译器：将DML语句翻译为一个执行方案，包括一系列执行引擎能理解的低级指令</li>
<li>查询执行引擎</li>
</ul>
<p><strong>事务</strong> 数据库应用中完成单一逻辑功能/任务的查询和更新的序列。</p>
<ul>
<li><strong>原子性（A）</strong> 事务的所有操作要么全做，要么全不做；由恢复机制实现；</li>
<li><strong>一致性（C）</strong>事务的隔离执行必须保证数据库的一致性（前后都处于一致状态）；由程序员用户负责；并发控制机制实现</li>
<li><strong>隔离性（I）</strong> 保证事务不受其他并发执行事务的影响</li>
<li><p><strong>持久性（C）</strong> 一个事务一旦提交，它对数据库的影响必须是永久的</p>
</li>
<li><p>事务管理器包括并发管理器和恢复管理器</p>
</li>
</ul>
<p><strong>C/S二层、三层体系结构</strong></p>
<ul>
<li>二层：user,application -&gt; dbs</li>
<li>三层：user,application-client -&gt; application-server -&gt; db</li>
</ul>
<p><strong>数据挖掘</strong> 应用一系列技术从大型数据库或数据仓库中提取人们感兴趣的信息和知识，是一类深层次的数据分析。</p>
<p><strong>数据库管理员（DBA）</strong> </p>
<ul>
<li>重要性：维护信息资源，管理多用户共享</li>
<li>作用：模式定义，存储结构、存取方法定义；模式修改，数据授权，日常维护</li>
</ul>
<h1 id="ch2-关系数据库"><a href="#ch2-关系数据库" class="headerlink" title="ch2 关系数据库"></a>ch2 关系数据库</h1><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p><strong>关系模型术语</strong> </p>
<ul>
<li>关系：二维表，由关系名标识</li>
<li>元组：表的一行</li>
<li>属性：表的一列</li>
<li>域：属性的取值范围</li>
</ul>
<p><strong>数据库模式和数据库实例</strong> 数据库模式是数据库的逻辑设计；数据库实例是给定时刻数据库中的一个快照</p>
<p><strong>关系模式和实例</strong> </p>
<ul>
<li><p><strong>关系模式</strong>：由属性序列和其域组成；</p>
</li>
<li><p>关系实例：满足关系模式的多个元组</p>
</li>
</ul>
<p><strong>码</strong>：能够唯一确定一个元组的最小属性集</p>
<ul>
<li><p><strong>超码</strong> 包含码的属性集。“一个或多个属性的集合，这些属性的集合可以使我们在一个关系中唯一地标识一个元组”</p>
</li>
<li><p><strong>候选码</strong> 一个关系的每个码</p>
</li>
<li><p><strong>主码</strong> 定义表时指定一个候选码</p>
</li>
<li><p><strong>外码</strong> 本关系的属性集，另一关系的码</p>
<ul>
<li><p>定义：关系R1的属性中包含另一个关系R2的主码，则称这个属性为R1的外码</p>
</li>
<li><p>R1称为<strong>参照关系</strong></p>
</li>
<li>R2称为<strong>被参照关系</strong></li>
</ul>
</li>
<li><p><strong>全码</strong> 表中找不出码，所有属性构成</p>
</li>
<li><p><strong>主属性</strong> 任一候选码中的属性</p>
</li>
<li><p><strong>非主属性</strong> 不在任何一个候选码中</p>
</li>
</ul>
<p><strong>关系模式的完整性</strong> </p>
<ul>
<li><strong>实体完整性</strong> 主码中的属性值不能为空值</li>
<li><strong>参照完整性</strong> 外部码要么等于被参照关系主码的某元组的值，要么为空值</li>
<li><strong>用户定义的完整性</strong></li>
</ul>
<h2 id="关系查询语言"><a href="#关系查询语言" class="headerlink" title="关系查询语言"></a>关系查询语言</h2><p><strong>查询语言</strong> 用户用来从数据库中请求获取信息的语言。</p>
<ul>
<li><p><strong>过程化语言</strong> 用户指导系统对数据库进行一系列操作以计算出所需结果。</p>
</li>
<li><p><strong>非过程化语言</strong> 用户只需描述所需信息，不用给出获得信息的具体过程。</p>
</li>
</ul>
<p><strong>关系查询语言</strong> 定义了一组运算集，这些运算可作用于表上，并输出表作为结果。这些运算可以组成表达式，表达所需的查询。</p>
<p><strong>关系演算</strong> 使用谓词逻辑来定义所需要的结果，<em>非过程化</em>。</p>
<ul>
<li><strong>元组关系演算</strong> 谓词变元为元组变量</li>
<li><strong>域关系演算</strong> 谓词变元为域变量</li>
</ul>
<p><strong>SQL性质</strong> 基于集合运算，非过程化与过程化结合</p>
<p><strong>关系数据语言的特点</strong> </p>
<ul>
<li>一体化：一般关系系统的数据语言都具有数据定义，数据操作和数据控制语言</li>
<li>非过程化</li>
<li>面向集合的存取方式（操作对象和结果都是一个或多个关系。非关系系统是一次一记录的形式。）</li>
</ul>
<p><strong>关系操作</strong> 关系操作是集合操作，操作的对象及结果都是集合，是“一次一集合的形式；非关系型的数据操作方式是一次一记录；可以用<strong>关系代数</strong>和<strong>关系演算</strong>两种方式等价表示</p>
<p><strong>关系运算</strong> 施加于单个或一对关系上，产生单个关系作为结果的运算。</p>
<ul>
<li><p>基本运算：</p>
<ul>
<li><p>一元运算：选择、投影、更名</p>
</li>
<li><p>多元运算：笛卡尔积、并、交、集合差</p>
</li>
</ul>
</li>
<li><p>其它运算：$\theta$连接，自然连接，除，赋值(ch6)</p>
</li>
</ul>
<p><strong>部分关系运算</strong></p>
<ul>
<li><strong>选择</strong> 返回输入关系中满足谓词条件的行</li>
<li><strong>投影</strong> 对输入关系的所有行输出指定的属性。从输出关系中去除重复元组。</li>
<li><strong>自然连接</strong> 从两个输入关系中输出这样的元组对：它们具有相同名字上的所有属性上取值相同</li>
<li><strong>笛卡尔积</strong> 从两个输入关系中输出所有的元组对</li>
<li><strong>并</strong> 输出两个输入关系中元组的并</li>
</ul>
<h1 id="ch3-SQL"><a href="#ch3-SQL" class="headerlink" title="ch3 SQL"></a>ch3 SQL</h1><p>略</p>
<h1 id="ch4-中级SQL"><a href="#ch4-中级SQL" class="headerlink" title="ch4 中级SQL"></a>ch4 中级SQL</h1><p><strong>SQL连接方式</strong></p>
<ul>
<li><p><strong>内连接</strong> 舍弃不匹配的元组</p>
</li>
<li><p><strong>外连接</strong> 通过在结果中创建包含空值元组的方式，保留那些在连接中丢失的元组</p>
</li>
<li><strong>左外连接</strong> 内连接+左侧失配的元组（缺少的右侧关系用null代替）</li>
<li>右外连接</li>
<li><strong>全外连接</strong> 内连接+左侧失配的元组+右侧失配的元组（缺少的用null代替）</li>
</ul>
<p><strong>视图</strong> 视图在概念上包含查询结构的元组，但是并不进行预计算和存储结果，只存储与视图关系产生关联的查询表达式；当视图关系被访问时才产生对应的查询结果。</p>
<p><strong>物化视图</strong> 某些DBMS允许存储视图，但保证如果定义视图的实际关系改变，视图也会跟着修改。</p>
<ul>
<li><strong>物化视图的维护</strong>（视图维护）：保证物化视图一直在最新状态</li>
</ul>
<p><strong>视图更新</strong> 用视图表达更新、插入、删除，一般不被允许，除非：</p>
<ul>
<li><strong>视图是可更新的</strong> <ul>
<li>from中只有一个数据库关系</li>
<li>select只包含属性名（无表达式等）</li>
<li>没出现在select中的属性可以取空值</li>
<li>无聚集函数等</li>
</ul>
</li>
</ul>
<p><strong>事务</strong> 共同执行一项任务的查询和更新语句的序列。</p>
<ul>
<li>事务的开始：sql的执行</li>
<li>事务的结束：<ul>
<li>commit</li>
<li>rollback</li>
</ul>
</li>
</ul>
<p><strong>完整性约束</strong> 保证授权用户对数据库的修改不会破坏数据的一致性。</p>
<ul>
<li><strong>函数依赖</strong> ch8</li>
<li>单个关系的约束<ul>
<li>not null 约束：排除空值</li>
<li>unique 约束：指定的属性形成候选码（可以为null）</li>
<li>check 约束：所有属性满足指定的谓词条件</li>
</ul>
</li>
<li><strong>参照完整性/子集依赖</strong> 一个关系给定属性集上的取值也在另一关系的特定属性集的取值上出现。（被参照关系一般为主码或候选码。广泛地，也可以不是。）</li>
</ul>
<p><strong>完整性</strong> 数据的正确性和相容性</p>
<p><strong>完整性检查</strong> DBMS提供的一种检查数据库中的数据是否满足规定的条件，以保证数据库中的数据是正确的，避免非法的不合语义的错误数据的输入和输出。</p>
<p><strong>完整性子系统</strong> </p>
<ul>
<li>数据库的非法更新情况<ul>
<li>数据本身是错误的</li>
<li>数据原来是正确的，操作或程序错误</li>
<li>由于系统故障，导致数据错误</li>
<li>事务的并发执行产生不正确结果</li>
<li>人为破坏</li>
</ul>
</li>
<li>完整性子系统功能<ul>
<li>监督事务执行，检查是否违反完整性规则</li>
<li>违反时采取相应措施</li>
</ul>
</li>
</ul>
<p><strong>完整性规则</strong> </p>
<ul>
<li><strong>完整性规则集</strong> 由DBA或程序员事先提供的有关数据约束的一组规则<ul>
<li>规则的构成<ul>
<li>约束条件：检查什么样的错误（性别只能为男女）</li>
<li>触发条件：什么时候使用规则进行检查（如插入元组时）</li>
<li>ELSE子句：若检查出错误，该怎样进行处理（显示错误）</li>
</ul>
</li>
<li>规则的分类<ul>
<li><strong>域完整性规则</strong>：属性取值范围</li>
<li><strong>域联系规则</strong>：在一个或多个关系中，属性间的联系影响约束(金额总和)</li>
<li><strong>关系完整性规则</strong>：更新操作对数据库中的值的影响和限制</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>SQL中的属性约束</strong></p>
<ul>
<li>SNAME CHAR(8) NOT NULL </li>
<li>CHECK(AGE&gt;15)</li>
</ul>
<p><strong>主码约束</strong> 主码值不允许空，也不允许出现重复</p>
<ul>
<li>意义：关系对应现实世界的实体集，元组对应实体，实体之间相互通过主码来唯一标识，若主码为空，则出现不可标识的实体。</li>
<li>SQL：PRIMARY KEY(Sno)或Sno CHAR(4) PRIMARY KEY</li>
</ul>
<p><strong>外码约束</strong> 参照完整性的一种实现。关系R包含的一个属性组F对应着关系S的<strong>主码</strong>，则将F称为R的外码，且R中每一个元组的F值要么等于S中的某个元组的F值，<strong>要么为空值</strong>。</p>
<ul>
<li><p><strong>外码约束与参照完整性约束区别</strong> 参照完整性<strong>不要求</strong>被参照完整性上的参照属性是主码或候选码。</p>
</li>
<li><p><strong>级联（cascade）删除</strong> 删除/更新被参照关系的元组， 也相应地删除/更新参照关系的元组。</p>
<ul>
<li><p>SQL：</p>
</li>
<li><pre><code>create table course
(...
foreign key (dept_name) references department
        on delete set null
        on update cascade, 

)
</code></pre></li>
</ul>
</li>
<li><p>级联以外的动作：set null， set default，restrict等</p>
</li>
</ul>
<p><strong>可延迟的约束</strong> 事务中的某一步也许会暂时违反完整性约束，但之后的一步则会消除这个违反，若允许这种修改则称为可延迟的约束。</p>
<ul>
<li>SQL：将<code>initially deferred</code>加入约束子句：<code>set constraints constrain-list deferred</code></li>
</ul>
<p><strong>SQL环境</strong> </p>
<ul>
<li>目录：系统级的元数据（包括表、视图、模式）</li>
<li>模式（分组相关对象，表、视图、存储模式）</li>
<li>用户授权标识</li>
</ul>
<p><strong>安全性控制</strong> 保护数据库以防止不合法的使用所造成的数据泄露和破坏。其基础措施是存取控制。</p>
<p><strong>安全性措施</strong></p>
<ul>
<li>物理级</li>
<li>人际级</li>
<li>操作系统级</li>
<li>网络级</li>
<li>数据库系统级</li>
</ul>
<p><strong>数据权限</strong> 数据的增删查改</p>
<p><strong>模式权限</strong> 创建/修改/删除关系</p>
<p><strong>视图的授权</strong>  对视图的访问会转换成对实际关系的访问，因此视图的访问权限&lt;=创建者的权限。然而，被授权查看视图的用户可以有更低的权限。</p>
<p><strong>模式的授权</strong> 模式的拥有者拥有对模式的基本授权，如增删关系及其属性、索引。</p>
<ul>
<li><strong>引用权限</strong> 允许用户创建关系时声明外码（外码可能会限制被参照关系）</li>
</ul>
<p><strong>权限的转移</strong> 获得了某些形式授权的用户可能被允许传递给其它用户。</p>
<p><strong>授权图</strong> 节点是用户，根节点是DBA，有向边$U_i \rightarrow U_j$表示用户$U_i$将某权限授给用户$U_j$；<strong>用户具有权限的充分必要条件是：当且仅当存在从根节点到该用户节点的路径</strong>。</p>
<p><strong>权限的收回</strong></p>
<ul>
<li><p><strong>级联收回</strong> 收回权限时，若该用户已将权限授予其它用户，则一并收回。</p>
</li>
<li><p><strong>防止级联收回</strong> restrict，如果存在任何级联收回则返回错误。</p>
</li>
<li><strong>仅收回grant option</strong> 仅收回用户授权给其它用户的权限</li>
<li><strong>角色授权</strong> 由当前角色授予其它用户权限，grant by current_role</li>
</ul>
<p><strong>角色</strong> 根据用户在组织机构中扮演的角色来把一组权限分配给用户，可避免级联收回。</p>
<p><strong>行级授权</strong> 对关系的特定元组或行的级别上的授权。</p>
<h1 id="ch5-高级SQL"><a href="#ch5-高级SQL" class="headerlink" title="ch5 高级SQL"></a>ch5 高级SQL</h1><p><strong>嵌入式SQL</strong> 在宿主语言中允许使用的SQL结构构成了嵌入式SQL。</p>
<ul>
<li>sql嵌入到宿主语言</li>
<li>通过预编译程序处理嵌入宿主语言的sql</li>
</ul>
<p><strong>动态SQL</strong> 用函数/方法与数据库API交互</p>
<p><strong>宿主语言</strong> 嵌入了SQL查询的语言。</p>
<p><strong>为什么使用嵌入式SQL</strong> </p>
<ul>
<li>SQL的表达能力相比高级语言有一定限制</li>
<li>非声明性动作：如用户交互、图形化显示等只能用高级语言实现</li>
</ul>
<p><strong>嵌入式SQL的执行过程</strong></p>
<ul>
<li>主语言+嵌入式SQL</li>
<li>预处理</li>
<li>主语言+函数调用</li>
<li>主语言编译器</li>
<li>主语言执行程序</li>
</ul>
<p><strong>宿主变量</strong> 既可以用在宿主语言语句中，也可以用在SQL语句中，用于传递二者间数据</p>
<p><strong>游标</strong> 在 查询结果的记录集合中移动的指针</p>
<ul>
<li>若返回单个元组，则不用游标</li>
<li>若返回多个元组，则使用游标</li>
</ul>
<p><strong>活动集</strong> select语句返回的元组集合</p>
<p><strong>当前行</strong> 活动集当前处理的那一行，游标即指向当前行的指针</p>
<p><strong>触发器</strong> 是一条语句，当对数据库做修改时，它自动被系统执行</p>
<ul>
<li>定义：触发器执行条件；触发器执行动作</li>
<li>作用：示警；满足特定条件自动执行某任务</li>
<li>事件：Insert，delete，update</li>
</ul>
<h1 id="ch6-关系代数"><a href="#ch6-关系代数" class="headerlink" title="ch6 关系代数"></a>ch6 关系代数</h1><p>略</p>
<h1 id="ch7-E-R模型"><a href="#ch7-E-R模型" class="headerlink" title="ch7 E-R模型"></a>ch7 E-R模型</h1><p><strong>设计阶段</strong></p>
<ul>
<li><strong>概念设计</strong>：将需求转换为数据库的概念模式</li>
<li><strong>功能需求规格说明</strong>：描述将在数据上执行的各类操作</li>
<li><strong>逻辑设计</strong>：将高层概念模式映射到数据库具体使用的数据类型</li>
</ul>
<p><strong>设计错误</strong></p>
<ul>
<li>冗余：不好的设计可能重复信息。</li>
<li>不完整：不好的设计可能使现实的某些方面难以甚至无法建模。（如只有开课没有课程）</li>
</ul>
<p><strong>实体-联系数据模型</strong> 允许定义代表数据库全局逻辑的企业模式来做到的</p>
<p><strong>实体集</strong> 共享相同性质或属性、具有相同类型的实体的集合</p>
<ul>
<li><strong>实体</strong> 现实世界中可区别于其他所有对象的一个“事物“或”对象“。</li>
<li>实体通过一组<strong>属性</strong>来表示。</li>
<li><strong>实体型</strong> 实体名和属性名组成实体型，对关系模式就是关系模式。</li>
</ul>
<p><strong>联系集</strong> 相同类型联系的集合</p>
<ul>
<li><strong>联系</strong> 多个实体间的相互关联</li>
<li><strong>联系实例</strong> 所建模的现实世界中实体的的一个关联。</li>
</ul>
<p><strong>参与</strong> 实体集之间的关联被称为参与，如$实体集E_1,E_2,E_3参与联系集R$</p>
<p><strong>递归的联系集</strong> 相同的实体集以不同角色多次参与同一个联系集。</p>
<ul>
<li><strong>角色</strong> 实体在联系中扮演的功能</li>
</ul>
<p><strong>描述性属性</strong> 用来描述联系的属性</p>
<p><strong>联系集的度</strong> 参与联系集的实体集的数目</p>
<ul>
<li>二元联系集：有两个实体集参与的联系集。大部分联系集都是二元的。</li>
</ul>
<p><strong>属性</strong> 实体特征，通过其值区分不同的实体</p>
<ul>
<li><strong>简单属性</strong> 不可再分的属性</li>
<li><strong>复合属性</strong> 可以划分为更小的属性。可以把相关属性都聚集起来，使模型更清晰（如出生日期年月日）。</li>
<li><strong>单值属性</strong> 每一个特定实体在此属性上取值唯一</li>
<li><strong>多值属性</strong> 一个特定实体有多于一个的取值</li>
</ul>
<p><strong>NULL</strong> “不适用”，“不存在的”，“缺失的”，“不知道的”</p>
<p><strong>派生属性</strong> 从其它相关的属性或实体派生出来的属性值（如学生的平均成绩）</p>
<p><strong>映射基数/基数比率</strong> 一个实体通过一个联系集能关联的实体个数</p>
<ul>
<li>一对一(1…1—-1…1)：实体集A的一个实体至多与实体集B的一个实体相关联（可以不关联）</li>
<li>一对多(0…*—-0…1)：实体集A的一个实体可与实体B的任意数目（包括0）个实体关联，B的每个实体则至多与A的一个实体相关联（也可以不关联）。</li>
<li>多对一(0…1—-0…*)：同</li>
<li>多对多(0…*—-0…*)：实体集A的一个实体可与实体B的任意数目（包括0）个实体关联，反之也成立。两个任意数目都包含0。</li>
<li>同一个实体集内和多个实体集间都存在这些映射关系。</li>
</ul>
<p><strong>参与约束</strong> 实体集中的每个实体有一个参与联系的次数，取最小最大minmax，定义为实体集的参与度。</p>
<ul>
<li><strong>部分参与</strong> 实体集E中的每个实体不一定参与到联系集R的某个联系中，或min=0；</li>
<li><strong>全部参与</strong> 实体集E中的每个实体都参与到联系集R的至少一个联系中，或min&gt;0</li>
</ul>
<p><strong>码，候选码，主码，超码</strong></p>
<p><strong>联系集的组成</strong>  各实体的主码和联系的属性</p>
<p><strong>联系集的主码结构</strong></p>
<ul>
<li>所有实体集的主码并集为联系集超码</li>
<li>若联系集为<strong>多对多</strong>的，则联系集主码由参与的实体集的主码并集构成</li>
<li>若为<strong>一对多</strong>或多对一的，则主码由多方的主码并集构成</li>
<li>若为<strong>一对一</strong>，由任意一方的主码构成</li>
</ul>
<p><strong>E_R图构件</strong></p>
<ul>
<li>实体集：分成两部分的矩形</li>
<li>联系集：菱形</li>
<li>属性：未分割的矩形</li>
<li>联系集属性：虚线连接属性矩形</li>
<li>实体的参与度：双线</li>
<li>连接到弱实体集的标志性实体集：双菱形</li>
</ul>
<p><strong>存在依赖</strong> 如果实体x的存在依赖于实体y的存在，称x存在依赖于y</p>
<ul>
<li><strong>支配实体</strong> y</li>
<li><strong>从属实体</strong> x</li>
<li>若y被删除，x也要被删除（如还款依赖于贷款）</li>
<li>若A $\underline{R}$ B若A存在依赖于B，则A全部参与联系集R</li>
</ul>
<p><strong>强实体集</strong> 有主码的实体集。</p>
<p><strong>弱实体集</strong> 没有足够的属性以形成主码的实体集</p>
<ul>
<li>弱实体集必须与标识实体集关联才有意义</li>
<li>弱实体集<strong>存在依赖</strong>于标识实体集</li>
<li><strong>标识性联系</strong> 弱实体集与标识实体集的联系，是从弱实体集到标识实体集多对一，且弱实体集在其中的完全参与。</li>
<li><strong>分辨符/部分码</strong> 弱实体用于区别依赖于某个特定强实体集的属性集合</li>
<li><strong>弱实体集的主码</strong> 由弱实体集的分辨符和标识实体集的主码构成</li>
<li>为什么采用弱实体集？<ul>
<li>避免数据冗余（强实体集码重复）</li>
<li>反映一个实体对另一个实体依赖的逻辑结构</li>
<li>弱实体集可以随强实体集的删除一并删除</li>
<li>弱实体集可以物理地随其强实体集存储</li>
</ul>
</li>
</ul>
<h2 id="转换为关系模式"><a href="#转换为关系模式" class="headerlink" title="转换为关系模式"></a>转换为关系模式</h2><p><strong>强实体集</strong>：</p>
<ul>
<li>实体集-&gt;关系</li>
<li>属性-&gt;关系的属性</li>
<li>复合属性-&gt;拆开</li>
<li><p>多值属性-&gt;将多值属性拆出为新关系+外码约束</p>
</li>
<li><p>若只包含主码和多值属性，则可以丢弃拆分后的只剩主码的关系</p>
</li>
</ul>
<p><strong>弱实体集</strong></p>
<ul>
<li>以分辨符+标识实体集的码为码，同时建外码约束</li>
</ul>
<p><strong>联系集</strong></p>
<ul>
<li><p>按照联系集的主码构成构造主码，再加上所有描述性属性</p>
</li>
<li><p>对所有引用的实体集的主码建外码约束（多值属性优化不建）</p>
</li>
</ul>
<p><strong>模式的合并</strong> </p>
<ul>
<li>若联系集中有一实体集全部参与，则可以将其合并入联系后的模式，而不必分解为三个模式（实体、联系、实体）</li>
<li>若为一对一联系，则允许部分合并（合并后置空值）</li>
</ul>
<p><strong>实体vs属性</strong></p>
<ul>
<li>能形成元组的为实体</li>
<li>需多个属性描述的为实体</li>
<li>多值属性还有其他属性，定义为实体</li>
</ul>
<p><strong>实体vs联系</strong></p>
<ul>
<li>描述实体间的行为时，为联系</li>
<li>静态为实体，动态为联系</li>
</ul>
<p><strong>n元还是二元</strong> 对非二元的联系集总可以通过插入联系集的方式更换为二元联系集。</p>
<p><strong>联系属性的布局</strong></p>
<ul>
<li>一对多联系集的属性仅可附加到多的一方</li>
<li>一对一联系集属性可附加到任意一方</li>
<li>多对多联系集属性必须作为联系集的属性</li>
</ul>
<h2 id="扩展E-R特性"><a href="#扩展E-R特性" class="headerlink" title="扩展E-R特性"></a>扩展E-R特性</h2><p><strong>特化</strong> 实体集中存在具有区别于该实体集内其它实体的特性的子集，根据这些差异特性对实体集进行分组。在实体集内部进行分组的过程称作特化。</p>
<ul>
<li>自顶而下、逐步求精</li>
<li>父类到子类</li>
<li><strong>成员身份约束</strong><ul>
<li><strong>重叠特化</strong> 一个实体集可能属于多个特化</li>
<li><strong>不相交特化</strong> 一个实体集必须属于至多一个特化实体集</li>
</ul>
</li>
<li><strong>完全性约束</strong><ul>
<li><strong>全部特化/概化</strong> 每个高层实体集必须属于一个低层实体集</li>
<li><strong>部分特化/概化</strong>（默认） 一些高层实体集可以不属于任何底层实体集</li>
</ul>
</li>
<li><strong>设计约束</strong><ul>
<li>条件定义的：一个实体成员资格的确定取决于一个条件/谓词表达式</li>
<li>用户定义的：用户手动指定一个实体归于哪个低层实体集</li>
</ul>
</li>
<li><strong>超类-子类联系</strong> 特化的另一种叫法。</li>
</ul>
<p><strong>概化</strong> 各个实体集根据共有的性质，合成一个较高层的实体集。</p>
<ul>
<li>自底而上，逐步合成</li>
</ul>
<p><strong>属性继承</strong> </p>
<ul>
<li>高层实体集的属性被低层实体集自动继承；</li>
<li>低层实体集特有的属性仅适用于某个特定的低层实体集；</li>
<li>子类同时继承地参与超类参与的联系集</li>
</ul>
<p><strong>层次结构</strong> 低层实体集仅参与到一个ISA联系集中，单继承</p>
<p><strong>格结构</strong> 低层实体集可以参与到多个ISA联系集中，多继承</p>
<p><strong>聚集</strong> 一种抽象，通过它联系被作为高层实体集</p>
<ul>
<li>将联系作为抽象实体</li>
<li>允许联系之间存在联系</li>
<li>将联系抽象进新的实体中</li>
</ul>
<p><strong>ER方案选择</strong></p>
<ul>
<li>用实体集还是属性</li>
<li>用实体集还是联系集</li>
<li>用二元联系还是多元联系</li>
<li>用强实体集还是弱实体集</li>
<li>是否要用概化</li>
<li>是否要用聚集</li>
</ul>
<h1 id="ch8-关系数据库设计"><a href="#ch8-关系数据库设计" class="headerlink" title="ch8 关系数据库设计"></a>ch8 关系数据库设计</h1><p><strong>四种异常现象</strong> </p>
<ul>
<li><strong>冗余度</strong> 数据的重复存储程度</li>
<li><strong>插入异常</strong> 由于设计上的缺陷，导致在插入某些数据时无法满足表的完整性约束，导致无法插入新数据</li>
<li><strong>删除异常</strong> 同上</li>
<li><strong>更新异常</strong> 同上</li>
</ul>
<p><strong>原子域</strong> 该域的元组不可分，不具有子结构</p>
<p><strong>范式</strong> 是关系模式的集合</p>
<p><strong>1NF</strong> 关系模式R的所有属性都是原子的</p>
<ul>
<li>1NF是二维表的要求</li>
<li>不满足1NF的数据库不能称为关系数据库</li>
</ul>
<p><strong>函数依赖</strong> 表达唯一标识特定属性的值的约束，形式化定义：若$\forall t_1[A]=t_2[A], 总有t_1[B]=t_2[B], 则称A\rightarrow B$</p>
<ul>
<li><strong>决定因素</strong> A</li>
<li><strong>依赖因素</strong> B</li>
<li>若$A\rightarrow B且B\rightarrow A$，则A与B为<strong>一一函数依赖</strong>，记作$A\leftrightarrow B$</li>
<li>函数依赖可<strong>重新导出候选码、超码、全码的定义</strong></li>
</ul>
<p><strong>函数依赖集</strong> R下的所有函数依赖组成的集合</p>
<p><strong>平凡的函数依赖</strong> $X\rightarrow Y，但Y\subseteq X$，反之为不平凡的函数依赖</p>
<p><strong>完全的函数依赖</strong> $X\rightarrow Y，但X的任意真子集X’ \not\rightarrow Y，记作X\xrightarrow{F} Y$，反之为部分的函数依赖</p>
<p><strong>传递的函数依赖</strong> 考虑非平凡的函数依赖$X\rightarrow Y, Y\not\rightarrow X, Y\rightarrow Z, 称Z对X传递函数依赖，记作X\rightarrow Z^{传递}$</p>
<p><strong>2NF</strong> 若关系模式$R\in 1NF$且所有的非主属性都完全函数依赖于R的码</p>
<ul>
<li><strong>主属性</strong> 所有候选码中的属性</li>
<li>2NF仍存在四种异常</li>
</ul>
<p><strong>函数依赖集的闭包</strong> R的函数依赖集F及F蕴含的全体函数依赖称为F的闭包$F^+$</p>
<p><strong>BCNF范式</strong> 对具有函数依赖集F的关系R，$F^+$中所有的形如$\alpha\rightarrow\beta$的函数依赖，至少有一项成立：</p>
<ul>
<li><ul>
<li>$\alpha\rightarrow\beta$是平凡的函数依赖</li>
</ul>
</li>
<li><ul>
<li>$\alpha$是R的一个超码</li>
</ul>
</li>
<li>加强了对$F^+$的所有$\alpha$的限定</li>
<li>不保持依赖</li>
</ul>
<p><strong>分解为BCNF</strong> 设计上用以下两个函数取代R：</p>
<ul>
<li>$(\alpha \cup \beta)$ 让$\alpha$变超码</li>
<li>$(R - (\beta - \alpha))$</li>
</ul>
<p><strong>3NF</strong> 类似BCNF，但是条件多了：$\beta - \alpha$的每个属性A都包含在R的一个候选码中</p>
<p><strong>armstrong公理</strong></p>
<ul>
<li>自反律：$X\subseteq Y则 X\to Y$</li>
<li>增补律：$X\subseteq Y则ZX\to ZY$</li>
<li>传递律：$X\to Y, Y\to Z则X\to Z$</li>
<li>合并律：$X\to Y, X\to Z则X\to YZ$</li>
<li>分解率：合并律反过来</li>
<li>伪传递律：$X\to Y, WY\to Z则WX\to Z$</li>
</ul>
<p><strong>$F^+$算法 </strong>循环：</p>
<ul>
<li>对所有f增补</li>
<li>对所有f传递</li>
<li>或：输出所有属性集闭包</li>
</ul>
<p><strong>属性集闭包</strong> 函数依赖集下，被X函数确定的所有属性集合</p>
<ul>
<li>求解方法：从result = {X}开始，每从result推出一个属性就将其加入到result中，直到其不发生变化</li>
</ul>
<p><strong>候选码求法</strong></p>
<ul>
<li>仅在箭头左边的属性一定在候选码中</li>
<li>求属性集闭包来求候选码</li>
</ul>
<p><strong>属性集等价判定方法</strong></p>
<ul>
<li>对F中的每个函数依赖$X\to Y$，检查Y是否在$X_G^+$</li>
<li>反之操作</li>
</ul>
<p><strong>无关属性</strong> 去除函数依赖的一个属性不改变该函数依赖集的闭包，称该属性为无关属性</p>
<ul>
<li><strong>左无关</strong> 去掉函数依赖左边的一个属性A，仅需判定去掉A后$(\alpha-A)_F^+$是否还包含$\beta$</li>
<li><strong>右无关</strong> 判定需要检验去掉右边的一个属性A后是否$\alpha$是否还能推出A</li>
</ul>
<p><strong>正则覆盖</strong> 满足$F_c$不含无关属性且左端都是唯一的</p>
<p><strong>计算$F_c$</strong> </p>
<ul>
<li>合并所有左端相同的函数依赖</li>
<li>找出并去掉无关属性</li>
<li>循环</li>
</ul>
<p><strong>无损分解</strong> 没有信息损失的分解</p>
<p><strong>无损分解定理</strong> 至少有一个成立时为无损分解（充分条件，仅考虑函数依赖为充要）</p>
<ul>
<li><p>$R_1 \cap R_2 = R_1$</p>
</li>
<li><p>$R_1 \cap R_2 = R_2$</p>
</li>
</ul>
<p><strong>保持依赖</strong> </p>
<ul>
<li>定义1:不依靠不同关系的连接就能验证R上成立的所有函数依赖，称分解保持依赖</li>
<li>定义2:限定$F_i$的并集等价于$F$的闭包时，称分解保持依赖</li>
</ul>
<p><strong>保持依赖判定算法</strong></p>
<ul>
<li>算法1:计算$F^+ ~~?= F’^+$</li>
<li>算法2:验证闭包的每一个函数依赖是否在某个Ri上成立<strong>（充分条件）</strong></li>
<li>算法3:result = $\alpha$</li>
<li>得到result限定Fi下的属性集闭包，加入到result中</li>
<li>循环</li>
<li>若$\beta \subseteq result$，则$\alpha\to\beta\in F$被保持</li>
</ul>
<p><strong>限定</strong> $F^+$中所有只包含$R_i$中属性的函数依赖的集合$F_i$</p>
<p><strong>BCNF分解算法</strong></p>
<ul>
<li>找出左侧非超码，与右侧无交集的函数依赖，分解</li>
<li>循环直至全部属于BCNF</li>
<li>无损，不能保证保持依赖</li>
</ul>
<p><strong>3NF分解算法</strong></p>
<ul>
<li>化为正则覆盖</li>
<li>构造</li>
<li>如果不含R的码，单独构造一个候选码关系</li>
<li>无损，保持依赖</li>
</ul>
<p><strong>4NF</strong></p>
<ul>
<li>类似3NF，只是换成了多值依赖</li>
</ul>
<p><strong>范式之间的关系</strong></p>
<ul>
<li>2NF 消除非主属性对码的部分函数依赖</li>
<li>3NF 消除非主属性对码的传递函数依赖</li>
<li>BCNF 消除主属性对码的传递函数依赖</li>
<li>4NF 消除非平凡的多值依赖</li>
</ul>
<h1 id="ch10-文件组织"><a href="#ch10-文件组织" class="headerlink" title="ch10 文件组织"></a>ch10 文件组织</h1><p><strong>文件组织</strong></p>
<ul>
<li>定长：文件头+自由链表</li>
<li><ul>
<li>变长</li>
<li>单记录提取：定长信息的初始部分</li>
<li>块记录提取：分槽的页</li>
</ul>
</li>
</ul>
<p><strong>文件组织记录</strong></p>
<ul>
<li>堆：自由空间图</li>
<li>顺序：溢出块</li>
<li>多表聚簇：聚簇码（反义：划分）</li>
<li>B+树</li>
<li>散列</li>
</ul>
<p><strong>缓冲区管理器</strong></p>
<ul>
<li>钉住</li>
<li>共享排他锁</li>
<li>LRU</li>
<li>立即丢弃</li>
<li>MRU</li>
</ul>
<h1 id="CH11-索引"><a href="#CH11-索引" class="headerlink" title="CH11 索引"></a>CH11 索引</h1><p><strong>聚集索引</strong> （允许稀疏索引，稠密索引）</p>
<p><strong>非聚集索引</strong> （只允许稠密索引）</p>
<p><strong>多级索引</strong></p>
<p><strong>索引的更新</strong>： 稠密索引/稀疏索引</p>
<p><strong>B+树索引</strong> 插入/删除$log_{\lceil n/2 \rceil}N$</p>
<p><strong>非唯一性搜索码</strong> 唯一化属性</p>
<p><strong>散列索引</strong></p>
<ul>
<li>桶</li>
<li>闭寻址：溢出链</li>
<li>桶溢出：溢出桶-》溢出链</li>
<li>偏斜：$(n_r/f_r)*(1+d)$</li>
<li>静态散列/动态散列</li>
</ul>
<p><strong>多码访问</strong></p>
<ul>
<li>单码索引</li>
<li>多码索引</li>
<li>覆盖索引</li>
<li>位图索引</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://dudujerry452.github.io">dudujerry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://dudujerry452.github.io/2025/08/21/db-summary/">https://dudujerry452.github.io/2025/08/21/db-summary/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://dudujerry452.github.io" target="_blank">dudujerry的Coding世界!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/database/">database</a></div><div class="post-share"><div class="social-share" data-image="/img/girl_avater.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/21/db-sql/" title="SQL笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SQL笔记</div></div><div class="info-2"><div class="info-item-1">SQL命令查询结构基本结构123select 列名    from 表名    where 条件表达式 产生一个关系作为结果，其中from中引用的表之间使用笛卡尔积连接 示例：给出所有女同学的姓名： 1select SNAME from S where SSEX = &#x27;女&#x27; 详细结构1234567select [ALL | DISTINCT] &lt;列名&gt;[, &lt;列名&gt; ] ...from &lt;表名&gt; [, &lt;表名&gt; ] ...[where &lt;行条件表达式&gt;][group by &lt;列名&gt; [, &lt;列名&gt; ] ...][having &lt;条件表达式&gt;][order by &lt;列名&gt; [asc | desc] ...] 工作过程：  读取from子句的表或视图做笛卡尔积 where子句找出满足条件表达式的元组 按group by子句指定列名分组，值相等的元素为一组，每个组产生结果表中的一条记录。可在每组中与聚集函数；若group子句带having，则只有满足条件的组才...</div></div></div></a><a class="pagination-related" href="/2025/08/20/discrete-math/" title="从集合论到置换群"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">从集合论到置换群</div></div><div class="info-2"><div class="info-item-1">集合论集合运算满足  交换、结合、分配律 幂等律 徳摩根律 吸收律 $A\cap (A\cup B) = A, A\cup(A\cap B) = A$  关系五大性质:   自反 对称 传递 反自反 反对称  其中, 只有自反不是if…, then …格式.  复合/逆关系满足结合律, 不满足交换律.  笛卡尔积的复合还是笛卡尔积.  $(R\circ S)^{-1} = S^{-1} \circ R^{-1}$ 自反和传递的集合S有$S \circ S = S$ 关系闭包 $r(R) = R\cup I_A$ $s(R) = R\cup R^{-1}$ $t(R) = \bigcup{i=1}^{\infty}R^i$, 对于有限集$t(R) = \bigcup^{n}{i=1}R^i$  除了满足传递性的集合的对称闭包不传递, 其他满足性质X的集合的各种闭包都满足性质X.  等价关系Def. 满足自反, 对称, 传递的关系 模m同余关系 $m | (i-j)\Leftrightarrow iR_mj \Leftrightarrow i\equiv j\ mod\ m$ 等价关...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/21/db-sql/" title="SQL笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-21</div><div class="info-item-2">SQL笔记</div></div><div class="info-2"><div class="info-item-1">SQL命令查询结构基本结构123select 列名    from 表名    where 条件表达式 产生一个关系作为结果，其中from中引用的表之间使用笛卡尔积连接 示例：给出所有女同学的姓名： 1select SNAME from S where SSEX = &#x27;女&#x27; 详细结构1234567select [ALL | DISTINCT] &lt;列名&gt;[, &lt;列名&gt; ] ...from &lt;表名&gt; [, &lt;表名&gt; ] ...[where &lt;行条件表达式&gt;][group by &lt;列名&gt; [, &lt;列名&gt; ] ...][having &lt;条件表达式&gt;][order by &lt;列名&gt; [asc | desc] ...] 工作过程：  读取from子句的表或视图做笛卡尔积 where子句找出满足条件表达式的元组 按group by子句指定列名分组，值相等的元素为一组，每个组产生结果表中的一条记录。可在每组中与聚集函数；若group子句带having，则只有满足条件的组才...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/girl_avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">dudujerry</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dudujerry452"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/dudujerry452" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:dudujerry452@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Love & Peace</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">数据库总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch1-%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">ch1 引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">ch2 关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">关系模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">3.2.</span> <span class="toc-text">关系查询语言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch3-SQL"><span class="toc-number">4.</span> <span class="toc-text">ch3 SQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch4-%E4%B8%AD%E7%BA%A7SQL"><span class="toc-number">5.</span> <span class="toc-text">ch4 中级SQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch5-%E9%AB%98%E7%BA%A7SQL"><span class="toc-number">6.</span> <span class="toc-text">ch5 高级SQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch6-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">ch6 关系代数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch7-E-R%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">ch7 E-R模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">转换为关系模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95E-R%E7%89%B9%E6%80%A7"><span class="toc-number">8.2.</span> <span class="toc-text">扩展E-R特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch8-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.</span> <span class="toc-text">ch8 关系数据库设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch10-%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">10.</span> <span class="toc-text">ch10 文件组织</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CH11-%E7%B4%A2%E5%BC%95"><span class="toc-number">11.</span> <span class="toc-text">CH11 索引</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/21/quickfps/" title="简单实现一个多人在线FPS Demo"><img src="/images/quickfps/pic1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单实现一个多人在线FPS Demo"/></a><div class="content"><a class="title" href="/2025/08/21/quickfps/" title="简单实现一个多人在线FPS Demo">简单实现一个多人在线FPS Demo</a><time datetime="2025-08-21T02:19:33.000Z" title="发表于 2025-08-21 10:19:33">2025-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/21/db-sql/" title="SQL笔记">SQL笔记</a><time datetime="2025-08-21T01:48:55.000Z" title="发表于 2025-08-21 09:48:55">2025-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/21/db-summary/" title="数据库总结">数据库总结</a><time datetime="2025-08-21T01:39:18.000Z" title="发表于 2025-08-21 09:39:18">2025-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/20/discrete-math/" title="从集合论到置换群">从集合论到置换群</a><time datetime="2025-08-20T13:33:19.000Z" title="发表于 2025-08-20 21:33:19">2025-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/20/nixos-install/" title="如何安装NixOS"><img src="/images/nixos.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何安装NixOS"/></a><div class="content"><a class="title" href="/2025/08/20/nixos-install/" title="如何安装NixOS">如何安装NixOS</a><time datetime="2025-08-20T08:20:54.000Z" title="发表于 2025-08-20 16:20:54">2025-08-20</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By dudujerry</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>